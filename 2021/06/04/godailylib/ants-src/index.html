<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Go 每日一库之 ants（源码赏析） - 大俊的博客</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="darjun" />
  <meta name="description" content="简介 继上一篇Go 每日一库之 ants，这篇文章我们来一起看看ants的源码。 Pool 通过上篇文章，我们知道ants池有两种创建方式： p, _ := ants." />

  <meta name="keywords" content="大俊, 大俊的博客, go, golang, gopher" />






<meta name="generator" content="Hugo 0.83.1" />


<link rel="canonical" href="https://darjun.github.io/2021/06/04/godailylib/ants-src/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">




<link rel="stylesheet" href="/css/custom.css">


<meta property="og:title" content="Go 每日一库之 ants（源码赏析）" />
<meta property="og:description" content="简介 继上一篇Go 每日一库之 ants，这篇文章我们来一起看看ants的源码。 Pool 通过上篇文章，我们知道ants池有两种创建方式： p, _ := ants." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://darjun.github.io/2021/06/04/godailylib/ants-src/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-06-04T07:26:23&#43;00:00" />
<meta property="article:modified_time" content="2021-06-04T07:26:23&#43;00:00" />

<meta itemprop="name" content="Go 每日一库之 ants（源码赏析）">
<meta itemprop="description" content="简介 继上一篇Go 每日一库之 ants，这篇文章我们来一起看看ants的源码。 Pool 通过上篇文章，我们知道ants池有两种创建方式： p, _ := ants."><meta itemprop="datePublished" content="2021-06-04T07:26:23&#43;00:00" />
<meta itemprop="dateModified" content="2021-06-04T07:26:23&#43;00:00" />
<meta itemprop="wordCount" content="8842">
<meta itemprop="keywords" content="Go 每日一库," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 每日一库之 ants（源码赏析）"/>
<meta name="twitter:description" content="简介 继上一篇Go 每日一库之 ants，这篇文章我们来一起看看ants的源码。 Pool 通过上篇文章，我们知道ants池有两种创建方式： p, _ := ants."/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-42862533-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">大俊</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/">首页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/about/">关于我</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/darjun" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      大俊
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/">首页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://darjun.github.io/about/">关于我</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/darjun" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Go 每日一库之 ants（源码赏析）</h1>
      
      <div class="post-meta">
        <time datetime="2021-06-04" class="post-time">
          2021-06-04
        </time>
        <div class="post-category">
            <a href="https://darjun.github.io/categories/go/"> Go </a>
            
          </div>
        <span class="more-meta"> 约 8842 字 </span>
          <span class="more-meta"> 预计阅读 18 分钟 </span>

        
        
          <span id="busuanzi_container_page_pv">
            | 阅读 <span id="busuanzi_value_page_pv"></span>
          </span>
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#简介">简介</a></li>
    <li><a href="#pool"><code>Pool</code></a>
      <ul>
        <li><a href="#pool创建"><code>Pool</code>创建</a></li>
        <li><a href="#loopqueue"><code>loopQueue</code></a></li>
        <li><a href="#再看pool创建">再看<code>Pool</code>创建</a></li>
      </ul>
    </li>
    <li><a href="#worker-结构">worker 结构</a></li>
    <li><a href="#提交任务">提交任务</a></li>
    <li><a href="#清理过期goworker">清理过期<code>goWorker</code></a></li>
    <li><a href="#容量动态修改">容量动态修改</a></li>
    <li><a href="#关闭和重新启动pool">关闭和重新启动<code>Pool</code></a></li>
    <li><a href="#poolwithfunc和workwithfunc"><code>PoolWithFunc</code>和<code>WorkWithFunc</code></a></li>
    <li><a href="#其他细节">其他细节</a>
      <ul>
        <li><a href="#task缓冲通道"><code>task</code>缓冲通道</a></li>
        <li><a href="#自旋锁">自旋锁</a></li>
      </ul>
    </li>
    <li><a href="#总结">总结</a></li>
    <li><a href="#参考">参考</a></li>
    <li><a href="#我">我</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="简介">简介</h2>
<p>继上一篇<a href="https://darjun.github.io/2021/06/03/godailylib/ants">Go 每日一库之 ants</a>，这篇文章我们来一起看看<code>ants</code>的源码。</p>
<h2 id="pool"><code>Pool</code></h2>
<p>通过上篇文章，我们知道<code>ants</code>池有两种创建方式：</p>
<ul>
<li><code>p, _ := ants.NewPool(cap)</code>：这种方式创建的池子对象需要调用<code>p.Submit(task)</code>提交任务，任务是一个无参数无返回值的函数；</li>
<li><code>p, _ := ants.NewPoolWithFunc(cap, func(interface{}))</code>：这种方式创建的池子对象需要指定池函数，并且使用<code>p.Invoke(arg)</code>调用池函数。<code>arg</code>就是传给池函数<code>func(interface{})</code>的参数。</li>
</ul>
<p>在<code>ants</code>中这两种池子使用不同的结构来表示：<code>ants.Pool</code>和<code>ants.PoolWithFunc</code>。我们先来介绍<code>Pool</code>。<code>PoolWithFunc</code>结构也是类似的，介绍完<code>Pool</code>之后，我们再简单比较一下它们。</p>
<p><code>Pool</code>结构定义在文件<code>pool.go</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// src/github.com/panjf2000/ants/pool.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">capacity</span> <span class="kt">int32</span>
  <span class="nx">running</span> <span class="kt">int32</span>
  <span class="nx">workers</span> <span class="nx">workerArray</span>
  <span class="nx">state</span> <span class="kt">int32</span>
  <span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Locker</span>
  <span class="nx">cond</span> <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Cond</span>
  <span class="nx">workerCache</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Pool</span>
  <span class="nx">blockingNum</span> <span class="kt">int</span>
  <span class="nx">options</span> <span class="o">*</span><span class="nx">Options</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>各个字段含义如下：</p>
<ul>
<li><code>capacity</code>：池容量，表示<code>ants</code>最多能创建的 goroutine 数量。如果为负数，表示容量无限制；</li>
<li><code>running</code>：已经创建的 worker goroutine 的数量；</li>
<li><code>workers</code>：存放一组 worker 对象，<code>workerArray</code>只是一个接口，表示一个 worker 容器，后面详述；</li>
<li><code>state</code>：记录池子当前的状态，是否已关闭（<code>CLOSED</code>）；</li>
<li><code>lock</code>：锁。<code>ants</code>自己实现了一个自旋锁。用于同步并发操作；</li>
<li><code>cond</code>：条件变量。处理任务等待和唤醒；</li>
<li><code>workerCache</code>：使用<code>sync.Pool</code>对象池管理和创建<code>worker</code>对象，提升性能；</li>
<li><code>blockingNum</code>：阻塞等待的任务数量；</li>
<li><code>options</code>：选项。上一篇文章已经详细介绍过了。</li>
</ul>
<p>这里明确一个概念，<code>ants</code>中为每个任务都是由 worker 对象来处理的，每个 worker 对象会对应创建一个 goroutine 来处理任务。<code>ants</code>中使用<code>goWorker</code>表示 worker：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// src/github.com/panjf2000/ants/worker.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">goWorker</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">pool</span> <span class="o">*</span><span class="nx">Pool</span>
  <span class="nx">task</span> <span class="kd">chan</span> <span class="kd">func</span><span class="p">()</span>
  <span class="nx">recycleTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>后文详细介绍这一块内容，现在我们只需要知道<code>Pool.workers</code>字段就是存放<code>goWorker</code>对象的容器。</p>
<h3 id="pool创建"><code>Pool</code>创建</h3>
<p>创建<code>Pool</code>对象需调用<code>ants.NewPool(size, options)</code>函数。省略了一些处理选项的代码，最终代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// src/github.com/panjf2000/ants/pool.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewPool</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">options</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Pool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...
</span><span class="c1"></span>  <span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Pool</span><span class="p">{</span>
    <span class="nx">capacity</span><span class="p">:</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">size</span><span class="p">),</span>
    <span class="nx">lock</span><span class="p">:</span>     <span class="nx">internal</span><span class="p">.</span><span class="nf">NewSpinLock</span><span class="p">(),</span>
    <span class="nx">options</span><span class="p">:</span>  <span class="nx">opts</span><span class="p">,</span>
  <span class="p">}</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">workerCache</span><span class="p">.</span><span class="nx">New</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">goWorker</span><span class="p">{</span>
      <span class="nx">pool</span><span class="p">:</span> <span class="nx">p</span><span class="p">,</span>
      <span class="nx">task</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">workerChanCap</span><span class="p">),</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">PreAlloc</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrInvalidPreAllocSize</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span> <span class="p">=</span> <span class="nf">newWorkerArray</span><span class="p">(</span><span class="nx">loopQueueType</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span> <span class="p">=</span> <span class="nf">newWorkerArray</span><span class="p">(</span><span class="nx">stackType</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="nx">p</span><span class="p">.</span><span class="nx">cond</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

  <span class="k">go</span> <span class="nx">p</span><span class="p">.</span><span class="nf">purgePeriodically</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">p</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码不难理解：</p>
<ul>
<li>创建<code>Pool</code>对象，设置容量，创建一个自旋锁来初始化<code>lock</code>字段，设置选项；</li>
<li>设置<code>workerCache</code>这个<code>sync.Pool</code>对象的<code>New</code>方法，在调用<code>sync.Pool</code>对象的<code>Get()</code>方法时，如果它没有缓存的 worker 对象了，则调用这个方法创建一个；</li>
<li>根据是否设置了预分配选项，创建不同类型的 workers；</li>
<li>使用<code>p.lock</code>锁创建一个条件变量；</li>
<li>最后启动一个 goroutine 用于定期清理过期的 worker。</li>
</ul>
<p><code>Pool.workers</code>字段为<code>workerArray</code>类型，这实际上是一个接口，表示一个 worker 容器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">workerArray</span> <span class="kd">interface</span> <span class="p">{</span>
  <span class="nb">len</span><span class="p">()</span> <span class="kt">int</span>
  <span class="nf">isEmpty</span><span class="p">()</span> <span class="kt">bool</span>
  <span class="nf">insert</span><span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">goWorker</span><span class="p">)</span> <span class="kt">error</span>
  <span class="nf">detach</span><span class="p">()</span> <span class="o">*</span><span class="nx">goWorker</span>
  <span class="nf">retrieveExpiry</span><span class="p">(</span><span class="nx">duration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">goWorker</span>
  <span class="nf">reset</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>每个方法从名字上很好理解含义：</p>
<ul>
<li><code>len() int</code>：worker 数量；</li>
<li><code>isEmpty() bool</code>：worker 数量是否为 0；</li>
<li><code>insert(worker *goWorker) error</code>：goroutine 任务执行结束后，将相应的 worker 放回<code>workerArray</code>中；</li>
<li><code>detach() *goWorker</code>：从<code>workerArray</code>中取出一个 worker；</li>
<li><code>retrieveExpiry(duration time.Duration) []*goWorker</code>：取出所有的过期 worker；</li>
<li><code>reset()</code>：重置容器。</li>
</ul>
<p><code>workerArray</code>在<code>ants</code>中有两种实现，即<code>workerStack</code>和<code>loopQueue</code>。</p>
<h4 id="workerstack"><code>workerStack</code></h4>
<p>我们先来介绍一下<code>workerStack</code>，它位于文件<code>worker_stack.go</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// src/github.com/panjf2000/ants/worker_stack.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">workerStack</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">items</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">goWorker</span>
  <span class="nx">expiry</span> <span class="p">[]</span><span class="o">*</span><span class="nx">goWorker</span>
  <span class="nx">size</span>   <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newWorkerStack</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">workerStack</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">workerStack</span><span class="p">{</span>
    <span class="nx">items</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">goWorker</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">size</span><span class="p">),</span>
    <span class="nx">size</span><span class="p">:</span>  <span class="nx">size</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li><code>items</code>：空闲的<code>worker</code>；</li>
<li><code>expiry</code>：过期的<code>worker</code>。</li>
</ul>
<p>goroutine 完成任务之后，<code>Pool</code>池会将相应的 worker 放回<code>workerStack</code>，调用<code>workerStack.insert()</code>直接<code>append</code>到<code>items</code>中即可：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">workerStack</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">goWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="nx">worker</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>新任务到来时，会调用<code>workerStack.detach()</code>从容器中取出一个空闲的 worker：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">workerStack</span><span class="p">)</span> <span class="nf">detach</span><span class="p">()</span> <span class="o">*</span><span class="nx">goWorker</span> <span class="p">{</span>
  <span class="nx">l</span> <span class="o">:=</span> <span class="nx">wq</span><span class="p">.</span><span class="nb">len</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>

  <span class="nx">w</span> <span class="o">:=</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span> <span class="c1">// avoid memory leaks
</span><span class="c1"></span>  <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span> <span class="p">=</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[:</span><span class="nx">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="k">return</span> <span class="nx">w</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里总是返回最后一个 worker，每次<code>insert()</code>也是<code>append</code>到最后，符合栈后进先出的特点，故称为<code>workerStack</code>。</p>
<p>这里有一个细节，由于切片的底层结构是数组，只要有引用数组的指针，数组中的元素就不会释放。这里取出切片最后一个元素后，将对应数组元素的指针设置为<code>nil</code>，主动释放这个引用。</p>
<p>上面说过新建<code>Pool</code>对象时会创建一个 goroutine 定期检查和清理过期的 worker。通过调用<code>workerArray.retrieveExpiry()</code>获取过期的 worker 列表。<code>workerStack</code>实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">workerStack</span><span class="p">)</span> <span class="nf">retrieveExpiry</span><span class="p">(</span><span class="nx">duration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="nx">goWorker</span> <span class="p">{</span>
  <span class="nx">n</span> <span class="o">:=</span> <span class="nx">wq</span><span class="p">.</span><span class="nb">len</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>

  <span class="nx">expiryTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="o">-</span><span class="nx">duration</span><span class="p">)</span>
  <span class="nx">index</span> <span class="o">:=</span> <span class="nx">wq</span><span class="p">.</span><span class="nf">binarySearch</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">expiryTime</span><span class="p">)</span>

  <span class="nx">wq</span><span class="p">.</span><span class="nx">expiry</span> <span class="p">=</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">expiry</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">if</span> <span class="nx">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="nx">wq</span><span class="p">.</span><span class="nx">expiry</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">wq</span><span class="p">.</span><span class="nx">expiry</span><span class="p">,</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[:</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">...</span><span class="p">)</span>
    <span class="nx">m</span> <span class="o">:=</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">,</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
    <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span> <span class="p">=</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[:</span><span class="nx">m</span><span class="p">]</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">expiry</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>实现使用二分查找法找到已过期的最近一个 worker。由于过期时间是按照 goroutine 执行任务后的空闲时间计算的，而<code>workerStack.insert()</code>入队顺序决定了，它们的过期时间是从早到晚的。所以可以使用二分查找：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">workerStack</span><span class="p">)</span> <span class="nf">binarySearch</span><span class="p">(</span><span class="nx">l</span><span class="p">,</span> <span class="nx">r</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">expiryTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">mid</span> <span class="kt">int</span>
  <span class="k">for</span> <span class="nx">l</span> <span class="o">&lt;=</span> <span class="nx">r</span> <span class="p">{</span>
    <span class="nx">mid</span> <span class="p">=</span> <span class="p">(</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="nx">expiryTime</span><span class="p">.</span><span class="nf">Before</span><span class="p">(</span><span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">mid</span><span class="p">].</span><span class="nx">recycleTime</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">r</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">l</span> <span class="p">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">r</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>二分查找的是最近过期的 worker，即将过期的 worker 的前一个。它和在它之前的 worker 已经全部过期了。</p>
<p>如果找到索引<code>index</code>，将<code>items</code>从开头到<code>index</code>（包括）的所有 worker 复制到<code>expiry</code>字段中。然后将<code>index</code>之后的所有未过期 worker 复制到切片头部，这里使用了<code>copy</code>函数。<code>copy</code>返回实际复制的数量，即未过期的 worker 数量<code>m</code>。然后将切片<code>items</code>从<code>m</code>开始所有的元素置为<code>nil</code>，避免内存泄漏，因为它们已经被复制到头部了。最后裁剪<code>items</code>切片，返回过期 worker 切片。</p>
<h3 id="loopqueue"><code>loopQueue</code></h3>
<p><code>loopQueue</code>实现基于循环队列，结构定义在文件<code>worker_loop_queue</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">loopQueue</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">items</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">goWorker</span>
  <span class="nx">expiry</span> <span class="p">[]</span><span class="o">*</span><span class="nx">goWorker</span>
  <span class="nx">head</span>   <span class="kt">int</span>
  <span class="nx">tail</span>   <span class="kt">int</span>
  <span class="nx">size</span>   <span class="kt">int</span>
  <span class="nx">isFull</span> <span class="kt">bool</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">newWorkerLoopQueue</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">loopQueue</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">loopQueue</span><span class="p">{</span>
    <span class="nx">items</span><span class="p">:</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">goWorker</span><span class="p">,</span> <span class="nx">size</span><span class="p">),</span>
    <span class="nx">size</span><span class="p">:</span>  <span class="nx">size</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于是循环队列，这里先创建好了一个长度为<code>size</code>的切片。循环队列有一个队列头指针<code>head</code>，指向第一个有元素的位置，一个队列尾指针<code>tail</code>，指向下一个可以存放元素的位置。所以一开始状态如下：</p>
<p><img src="/img/in-post/godailylib/ants-src1.png#center" alt=""></p>
<p>在<code>tail</code>处添加元素，添加后<code>tail</code>指针后移。在<code>head</code>处取出元素，取出后<code>head</code>指针也后移。进行一段时间操作后，队列状态如下：</p>
<p><img src="/img/in-post/godailylib/ants-src2.png#center" alt=""></p>
<p><code>head</code>或<code>tail</code>指针到队列尾了，需要回绕。所以可能出现这种情况：</p>
<p><img src="/img/in-post/godailylib/ants-src3.png#center" alt=""></p>
<p>当<code>tail</code>指针赶上<code>head</code>指针了，说明队列就满了：</p>
<p><img src="/img/in-post/godailylib/ants-src4.png#center" alt=""></p>
<p>当<code>head</code>指针赶上<code>tail</code>指针了，队列再次为空：</p>
<p><img src="/img/in-post/godailylib/ants-src5.png#center" alt=""></p>
<p>根据示意图，我们再来看<code>loopQueue</code>的操作方法就很简单了。</p>
<p>由于<code>head</code>和<code>tail</code>相等的情况有可能是队列空，也有可能是队列满，所以<code>loopQueue</code>中增加一个<code>isFull</code>字段以示区分。goroutine 完成任务之后，会将对应的 worker 对象放回<code>loopQueue</code>，执行的是<code>insert()</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">loopQueue</span><span class="p">)</span> <span class="nf">insert</span><span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">goWorker</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errQueueIsReleased</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">isFull</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">errQueueIsFull</span>
  <span class="p">}</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">wq</span><span class="p">.</span><span class="nx">tail</span><span class="p">]</span> <span class="p">=</span> <span class="nx">worker</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">tail</span><span class="o">++</span>

  <span class="k">if</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
    <span class="nx">wq</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">head</span> <span class="p">{</span>
    <span class="nx">wq</span><span class="p">.</span><span class="nx">isFull</span> <span class="p">=</span> <span class="kc">true</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法执行的就是循环队列的入队流程，注意如果插入后<code>tail==head</code>了，说明队列满了，设置<code>isFull</code>字段。</p>
<p>新任务到来调用<code>loopQueeue.detach()</code>方法获取一个空闲的 worker 结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">loopQueue</span><span class="p">)</span> <span class="nf">detach</span><span class="p">()</span> <span class="o">*</span><span class="nx">goWorker</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">wq</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span>
  <span class="p">}</span>

  <span class="nx">w</span> <span class="o">:=</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">wq</span><span class="p">.</span><span class="nx">head</span><span class="p">]</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">wq</span><span class="p">.</span><span class="nx">head</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">head</span><span class="o">++</span>
  <span class="k">if</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">head</span> <span class="o">==</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">size</span> <span class="p">{</span>
    <span class="nx">wq</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="p">}</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">isFull</span> <span class="p">=</span> <span class="kc">false</span>

  <span class="k">return</span> <span class="nx">w</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法对应的是循环队列的出队流程，注意每次出队后，队列肯定不满了，<code>isFull</code>要重置为<code>false</code>。</p>
<p>与<code>workerStack</code>结构一样，先入的 worker 对象过期时间早，后入的晚，获取过期 worker 的方法与<code>workerStack</code>中类似，只是没有使用二分查找了。这里就不赘述了。</p>
<h3 id="再看pool创建">再看<code>Pool</code>创建</h3>
<p>介绍完两种<code>workerArray</code>的实现之后，再来看<code>Pool</code>的创建函数中<code>workers</code>字段的设置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">PreAlloc</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">size</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrInvalidPreAllocSize</span>
  <span class="p">}</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span> <span class="p">=</span> <span class="nf">newWorkerArray</span><span class="p">(</span><span class="nx">loopQueueType</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span> <span class="p">=</span> <span class="nf">newWorkerArray</span><span class="p">(</span><span class="nx">stackType</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>newWorkerArray()</code>定义在文件<code>worker_array.go</code>中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">arrayType</span> <span class="kt">int</span>

<span class="kd">const</span> <span class="p">(</span>
  <span class="nx">stackType</span> <span class="nx">arrayType</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span>
  <span class="nx">loopQueueType</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">newWorkerArray</span><span class="p">(</span><span class="nx">aType</span> <span class="nx">arrayType</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">workerArray</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="nx">aType</span> <span class="p">{</span>
  <span class="k">case</span> <span class="nx">stackType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">newWorkerStack</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
  <span class="k">case</span> <span class="nx">loopQueueType</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">newWorkerLoopQueue</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
  <span class="k">default</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">newWorkerStack</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>即如果设置了预分配选项，就采用<code>loopQueue</code>结构。否则就采用<code>stack</code>的结构。</p>
<h2 id="worker-结构">worker 结构</h2>
<p>介绍完<code>Pool</code>的创建和结构，我们来看看 worker 的结构。在<code>ants</code>中 worker 用结构体<code>goWorker</code>表示，定义在文件<code>worker.go</code>中。它的结构非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// src/github.com/panjf2000/ants/worker.go
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">goWorker</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">pool</span> <span class="o">*</span><span class="nx">Pool</span>
  <span class="nx">task</span> <span class="kd">chan</span> <span class="kd">func</span><span class="p">()</span>
  <span class="nx">recycleTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>具体字段含义很明显：</p>
<ul>
<li><code>pool</code>：持有 goroutine 池的引用；</li>
<li><code>task</code>：任务通道，通过这个通道将类型为<code>func ()</code>的函数作为任务发送给<code>goWorker</code>；</li>
<li><code>recyleTime</code>：这个字段记录<code>goWorker</code>什么时候被放回池中（即什么时候开始空闲）。其完成任务后，在将其放回 goroutine 池的时候设置。</li>
</ul>
<p><code>goWorker</code>创建时会调用<code>run()</code>方法，<code>run()</code>方法中启动一个新 goroutine 处理任务。<code>run()</code>主体流程非常简单：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">goWorker</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">w</span><span class="p">.</span><span class="nx">task</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">f</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="nf">f</span><span class="p">()</span>
      <span class="k">if</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">revertWorker</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法启动一个新的 goroutine，然后不停地从<code>task</code>通道中接收任务，然后执行任务，任务执行完成之后调用池对象的<code>revertWorker()</code>方法将该<code>goWorker</code>对象放回池中，以便下次取出处理新的任务。<code>revertWorker()</code>方法后面会详细分析。</p>
<p>这里注意，实际上<code>for f := range w.task</code>这个循环直到通道<code>task</code>关闭或取出为<code>nil</code>的任务才会终止。所以这个 goroutine 一直在运行，这正是<code>ants</code>高性能的关键所在。每个<code>goWorker</code>只会启动一次 goroutine， 后续重复利用这个 goroutine。goroutine 每次只执行一个任务就会被放回池中。</p>
<p>还有一个细节，<strong>如果放回操作失败，则会调用<code>return</code>，这会让 goroutine 运行结束，防止 goroutine 泄漏</strong>。</p>
<p>这里<code>f == nil</code>为 true 时<code>return</code>，也是一个细节点，我们后面讲池关闭的时候会详细介绍。</p>
<p>下面我们看看<code>run()</code>方法的异常处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">workerCache</span><span class="p">.</span><span class="nf">Put</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">p</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">ph</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">PanicHandler</span><span class="p">;</span> <span class="nx">ph</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="nf">ph</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;worker exits from a panic: %v\n&#34;</span><span class="p">,</span> <span class="nx">p</span><span class="p">)</span>
      <span class="kd">var</span> <span class="nx">buf</span> <span class="p">[</span><span class="mi">4096</span><span class="p">]</span><span class="kt">byte</span>
      <span class="nx">n</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">Stack</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:],</span> <span class="kc">false</span><span class="p">)</span>
      <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;worker exits from panic: %s\n&#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">buf</span><span class="p">[:</span><span class="nx">n</span><span class="p">]))</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nx">cond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
<span class="p">}()</span>
</code></pre></td></tr></table>
</div>
</div><p>简单来说，就是在<code>defer</code>中通过<code>recover()</code>函数捕获任务执行过程中抛出的<code>panic</code>。这时任务执行失败，goroutine 也结束了。但是<code>goWorker</code>对象还是可以重复利用，所以<code>defer</code>函数一开始调用<code>w.pool.workerCache.Put(w)</code>将<code>goWorker</code>对象放回<code>sync.Pool</code>池中。</p>
<p>接着就是处理<code>panic</code>，如果选项中指定了<code>panic</code>处理器，直接调用这个处理器。否则，<code>ants</code>调用选项中设置的<code>Logger</code>记录一些日志，如堆栈，<code>panic</code>信息等。</p>
<p>最后需要调用<code>w.pool.cond.Signal()</code>通知现在有空闲的<code>goWorker</code>了。因为我们实际运行的<code>goWorker</code>数量由于<code>panic</code>少了一个，而池中可能有其他任务在等待处理。</p>
<h2 id="提交任务">提交任务</h2>
<p>接下来，通过提交任务就可以串起整个流程。由上一篇文章我们知道，可以调用池对象的<code>Submit()</code>方法提交任务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Submit</span><span class="p">(</span><span class="nx">task</span> <span class="kd">func</span><span class="p">())</span> <span class="kt">error</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">IsClosed</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ErrPoolClosed</span>
  <span class="p">}</span>
  <span class="kd">var</span> <span class="nx">w</span> <span class="o">*</span><span class="nx">goWorker</span>
  <span class="k">if</span> <span class="nx">w</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">retrieveWorker</span><span class="p">();</span> <span class="nx">w</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">ErrPoolOverload</span>
  <span class="p">}</span>
  <span class="nx">w</span><span class="p">.</span><span class="nx">task</span> <span class="o">&lt;-</span> <span class="nx">task</span>
  <span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>首先判断池是否已关闭，然后调用<code>retrieveWorker()</code>方法获取一个空闲的 worker，然后将任务<code>task</code>发送到 worker 的任务通道。下面是<code>retrieveWorker()</code>实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">retrieveWorker</span><span class="p">()</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">goWorker</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

  <span class="nx">w</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span><span class="p">.</span><span class="nf">detach</span><span class="p">()</span>
  <span class="k">if</span> <span class="nx">w</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">capacity</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Cap</span><span class="p">();</span> <span class="nx">capacity</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">capacity</span> <span class="p">&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Running</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="nf">spawnWorker</span><span class="p">()</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">Nonblocking</span> <span class="p">{</span>
      <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
      <span class="k">return</span>
    <span class="p">}</span>
  <span class="nx">Reentry</span><span class="p">:</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">MaxBlockingTasks</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">blockingNum</span> <span class="o">&gt;=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">MaxBlockingTasks</span> <span class="p">{</span>
      <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">blockingNum</span><span class="o">++</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">cond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">blockingNum</span><span class="o">--</span>
    <span class="kd">var</span> <span class="nx">nw</span> <span class="kt">int</span>
    <span class="k">if</span> <span class="nx">nw</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Running</span><span class="p">();</span> <span class="nx">nw</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
      <span class="k">if</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nf">IsClosed</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">spawnWorker</span><span class="p">()</span>
      <span class="p">}</span>
      <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">w</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span><span class="p">.</span><span class="nf">detach</span><span class="p">();</span> <span class="nx">w</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">nw</span> <span class="p">&lt;</span> <span class="nx">capacity</span> <span class="p">{</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
        <span class="nf">spawnWorker</span><span class="p">()</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="k">goto</span> <span class="nx">Reentry</span>
    <span class="p">}</span>

    <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个方法稍微有点复杂，我们一点点来看。首先调用<code>p.workers.detach()</code>获取<code>goWorker</code>对象。<code>p.workers</code>是<code>loopQueue</code>或者<code>workerStack</code>对象，它们都实现了<code>detach()</code>方法，前面已经介绍过了。</p>
<p>如果返回了一个<code>goWorker</code>对象，说明有空闲 goroutine，直接返回。</p>
<p>否则，池容量还没用完（即容量大于正在工作的<code>goWorker</code>数量），则调用<code>spawnWorker()</code>新建一个<code>goWorker</code>，执行其<code>run()</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="nx">spawnWorker</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">w</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workerCache</span><span class="p">.</span><span class="nf">Get</span><span class="p">().(</span><span class="o">*</span><span class="nx">goWorker</span><span class="p">)</span>
  <span class="nx">w</span><span class="p">.</span><span class="nf">run</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>否则，池容量已用完。如果设置了<strong>非阻塞</strong>选项，则直接返回。否则，如果设置了最大阻塞队列长度上限，且当前阻塞等待的任务数量已经达到这个上限，直接返回。否则，阻塞等待数量 +1，调用<code>p.cond.Wait()</code>等待。</p>
<p>然后<code>goWorker.run()</code>完成一个任务后，调用池的<code>revertWorker()</code>方法放回<code>goWorker</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">revertWorker</span><span class="p">(</span><span class="nx">worker</span> <span class="o">*</span><span class="nx">goWorker</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">capacity</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Cap</span><span class="p">();</span> <span class="p">(</span><span class="nx">capacity</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Running</span><span class="p">()</span> <span class="p">&gt;</span> <span class="nx">capacity</span><span class="p">)</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nf">IsClosed</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>
  <span class="nx">worker</span><span class="p">.</span><span class="nx">recycleTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>

  <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">IsClosed</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

  <span class="nx">err</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span><span class="p">.</span><span class="nf">insert</span><span class="p">(</span><span class="nx">worker</span><span class="p">)</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

  <span class="nx">p</span><span class="p">.</span><span class="nx">cond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">()</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="k">return</span> <span class="kc">true</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里设置了<code>goWorker</code>的<code>recycleTime</code>字段，用于判定过期。然后将<code>goWorker</code>放回池。<code>workers</code>的<code>insert()</code>方法前面也已经分析过了。</p>
<p>接着调用<code>p.cond.Signal()</code>唤醒之前<code>retrieveWorker()</code>方法中的等待。<code>retrieveWorker()</code>方法继续执行，阻塞等待数量 -1，这里判断当前<code>goWorker</code>的数量（也即 goroutine 数量）。如果数量等于 0，很有可能池子刚刚执行了<code>Release()</code>关闭，这时需要判断池是否处于关闭状态，如果是则直接返回。否则，调用<code>spawnWorker()</code>创建一个新的<code>goWorker</code>并执行其<code>run()</code>方法。</p>
<p>如果当前<code>goWorker</code>数量不为 0，则调用<code>p.workers.detach()</code>取出一个空闲的<code>goWorker</code>返回。这个操作有可能失败，因为可能同时有多个 goroutine 在等待，唤醒的时候只有部分 goroutine 能获取到<code>goWorker</code>。如果失败了，其容量还未用完，直接创建新的<code>goWorker</code>，反之重新执行阻塞等待逻辑。</p>
<p>这里有很多加锁和解锁的逻辑，再加上和信号量混在一起很难看明白。其实只需要知道一点就很简单了，那就是<code>p.cond.Wait()</code>内部会将当前 goroutine 挂起，然后解开它持有的锁，即会调用<code>p.lock.Unlock()</code>。这也是为什么<code>revertWorker()</code>中<code>p.lock.Lock()</code>加锁能成功的原因。然后<code>p.cond.Signal()</code>或<code>p.cond.Broadcast()</code>会唤醒因为<code>p.cond.Wait()</code>而挂起的 goroutine，但是需要<code>Signal()/Broadcast()</code>所在 goroutine 调用解锁方法。而调用<code>p.cond.Wait()</code>的 goroutine 被唤醒之后，内部会重新执行加锁操作（即调用<code>p.lock.Lock()</code>），所以<code>p.cond.Wait()</code>之后的逻辑还是在有锁的状态下执行的。</p>
<p>最后，放上整体流程图：</p>
<p><img src="/img/in-post/godailylib/ants1.png#center" alt=""></p>
<h2 id="清理过期goworker">清理过期<code>goWorker</code></h2>
<p>在<code>NewPool()</code>函数中会启动一个 goroutine 定期清理过期的<code>goWorker</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">purgePeriodically</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">heartbeat</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">NewTicker</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">ExpiryDuration</span><span class="p">)</span>
  <span class="k">defer</span> <span class="nx">heartbeat</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

  <span class="k">for</span> <span class="k">range</span> <span class="nx">heartbeat</span><span class="p">.</span><span class="nx">C</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">IsClosed</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">break</span>
    <span class="p">}</span>

    <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="nx">expiredWorkers</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span><span class="p">.</span><span class="nf">retrieveExpiry</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">ExpiryDuration</span><span class="p">)</span>
    <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">expiredWorkers</span> <span class="p">{</span>
      <span class="nx">expiredWorkers</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">task</span> <span class="o">&lt;-</span> <span class="kc">nil</span>
      <span class="nx">expiredWorkers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Running</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
      <span class="nx">p</span><span class="p">.</span><span class="nx">cond</span><span class="p">.</span><span class="nf">Broadcast</span><span class="p">()</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果池子已关闭，直接退出 goroutine。由选项<code>ExpiryDuration</code>来设置清理的间隔，如果没有设置该选项，采用默认值 1s：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// src/github.com/panjf2000/ants/pool.go
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewPool</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">options</span> <span class="o">...</span><span class="nx">Option</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Pool</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">expiry</span> <span class="o">:=</span> <span class="nx">opts</span><span class="p">.</span><span class="nx">ExpiryDuration</span><span class="p">;</span> <span class="nx">expiry</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">ErrInvalidPoolExpiry</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">expiry</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="nx">opts</span><span class="p">.</span><span class="nx">ExpiryDuration</span> <span class="p">=</span> <span class="nx">DefaultCleanIntervalTime</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// src/github.com/panjf2000/ants/pool.go
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
  <span class="nx">DefaultCleanIntervalTime</span> <span class="p">=</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>然后就是每个清理周期，调用<code>p.workers.retrieveExpiry()</code>方法，取出过期的<code>goWorker</code>。<strong>因为由这些<code>goWorker</code>启动的 goroutine 还阻塞在通道<code>task</code>上，所以要向该通道发送一个<code>nil</code>值，而<code>goWorker.run()</code>方法中接收到一个值为<code>nil</code>的任务会<code>return</code>，结束 goroutine，避免了 goroutine 泄漏</strong>。</p>
<p>如果所有<code>goWorker</code>都被清理掉了，可能这时还有 goroutine 阻塞在<code>retrieveWorker()</code>方法中的<code>p.cond.Wait()</code>上，所以这里需要调用<code>p.cond.Broadcast()</code>唤醒这些 goroutine。</p>
<h2 id="容量动态修改">容量动态修改</h2>
<p>在运行过程中，可以动态修改池的容量。调用<code>p.Tune(size int)</code>方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Tune</span><span class="p">(</span><span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">capacity</span> <span class="o">:=</span> <span class="nx">p</span><span class="p">.</span><span class="nf">Cap</span><span class="p">();</span> <span class="nx">capacity</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="nx">size</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">size</span> <span class="o">==</span> <span class="nx">capacity</span> <span class="o">||</span> <span class="nx">p</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">PreAlloc</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">capacity</span><span class="p">,</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这里只是简单设置了一下新的容量，不影响当前正在执行的<code>goWorker</code>，而且如果设置了预分配选项，容量不能再次设置。</p>
<p>下次执行<code>revertWorker()</code>的时候就会以新的容量判断是否能放回，下次执行<code>retrieveWorker()</code>的时候也会以新容量判断是否能创建新<code>goWorker</code>。</p>
<h2 id="关闭和重新启动pool">关闭和重新启动<code>Pool</code></h2>
<p>使用完成之后，需要关闭<code>Pool</code>，避免 goroutine 泄漏。调用池对象的<code>Release()</code>方法关闭：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Release</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">CLOSED</span><span class="p">)</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">workers</span><span class="p">.</span><span class="nf">reset</span><span class="p">()</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
  <span class="nx">p</span><span class="p">.</span><span class="nx">cond</span><span class="p">.</span><span class="nf">Broadcast</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>调用<code>p.workers.reset()</code>结束<code>loopQueue</code>或<code>wokerStack</code>中的 goroutine，做一些清理工作，同时为了防止有 goroutine 阻塞在<code>p.cond.Wait()</code>上，执行一次<code>p.cond.Broadcast()</code>。</p>
<p><code>workerStack</code>与<code>loopQueue</code>的<code>reset()</code>基本相同，即发送<code>nil</code>到<code>task</code>通道从而结束 goroutine，然后重置各个字段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// loopQueue 版本
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">loopQueue</span><span class="p">)</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">wq</span><span class="p">.</span><span class="nf">isEmpty</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span>
  <span class="p">}</span>

<span class="nx">Releasing</span><span class="p">:</span>
  <span class="k">if</span> <span class="nx">w</span> <span class="o">:=</span> <span class="nx">wq</span><span class="p">.</span><span class="nf">detach</span><span class="p">();</span> <span class="nx">w</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">w</span><span class="p">.</span><span class="nx">task</span> <span class="o">&lt;-</span> <span class="kc">nil</span>
    <span class="k">goto</span> <span class="nx">Releasing</span>
  <span class="p">}</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span> <span class="p">=</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">size</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="mi">0</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="mi">0</span>
<span class="p">}</span>

<span class="c1">// stack 版本
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">wq</span> <span class="o">*</span><span class="nx">workerStack</span><span class="p">)</span> <span class="nf">reset</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">wq</span><span class="p">.</span><span class="nb">len</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
    <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">task</span> <span class="o">&lt;-</span> <span class="kc">nil</span>
    <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
  <span class="p">}</span>
  <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span> <span class="p">=</span> <span class="nx">wq</span><span class="p">.</span><span class="nx">items</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>池关闭后还可以调用<code>Reboot()</code>重启：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">Pool</span><span class="p">)</span> <span class="nf">Reboot</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">.</span><span class="nx">state</span><span class="p">,</span> <span class="nx">CLOSED</span><span class="p">,</span> <span class="nx">OPENED</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nx">p</span><span class="p">.</span><span class="nf">purgePeriodically</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>由于<code>p.purgePeriodically()</code>在<code>p.Release()</code>之后检测到池关闭就直接退出了，这里需要重新开启一个 goroutine 定期清理。</p>
<h2 id="poolwithfunc和workwithfunc"><code>PoolWithFunc</code>和<code>WorkWithFunc</code></h2>
<p>上一篇文章中我们还介绍了另一种方式创建<code>Pool</code>，即<code>NewPoolWithFunc()</code>，指定一个函数。后面提交任务时调用<code>p.Invoke()</code>提供参数就可以执行该函数了。这种方式创建的 Pool 和 Woker 结构如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">PoolWithFunc</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">workers</span> <span class="p">[]</span><span class="o">*</span><span class="nx">goWorkerWithFunc</span>
  <span class="nx">poolFunc</span> <span class="kd">func</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">goWorkerWithFunc</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">pool</span> <span class="o">*</span><span class="nx">PoolWithFunc</span>
  <span class="nx">args</span> <span class="kd">chan</span> <span class="kd">interface</span><span class="p">{}</span>
  <span class="nx">recycleTime</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>与前面介绍的<code>Pool</code>和<code>goWorker</code>大体相似，只是<code>PoolWithFunc</code>保存了传入的函数对象，使用数组保存 worker。<code>goWorkerWithFunc</code>以<code>interface{}</code>为<code>args</code>通道的数据类型，其实也好理解，因为已经有函数了，只需要传入数据作为参数就可以运行了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">goWorkerWithFunc</span><span class="p">)</span> <span class="nf">run</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">args</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">w</span><span class="p">.</span><span class="nx">args</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">args</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="k">return</span>
      <span class="p">}</span>
      <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">poolFunc</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span>
      <span class="k">if</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.</span><span class="nx">pool</span><span class="p">.</span><span class="nf">revertWorker</span><span class="p">(</span><span class="nx">w</span><span class="p">);</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
        <span class="k">return</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>从通道接收函数参数，执行池中保存的函数对象。</p>
<h2 id="其他细节">其他细节</h2>
<h3 id="task缓冲通道"><code>task</code>缓冲通道</h3>
<p>还记得创建<code>p.workerCache</code>这个<code>sync.Pool</code>对象的代码么：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="nx">p</span><span class="p">.</span><span class="nx">workerCache</span><span class="p">.</span><span class="nx">New</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="nx">goWorker</span><span class="p">{</span>
    <span class="nx">pool</span><span class="p">:</span> <span class="nx">p</span><span class="p">,</span>
    <span class="nx">task</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">workerChanCap</span><span class="p">),</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>在<code>sync.Pool</code>中没有<code>goWorker</code>对象时，调用<code>New()</code>方法创建一个，注意到这里创建的<code>task</code>通道使用<code>workerChanCap</code>作为容量。这个变量定义在<code>ants.go</code>文件中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">var</span> <span class="p">(</span>
  <span class="c1">// workerChanCap determines whether the channel of a worker should be a buffered channel
</span><span class="c1"></span>  <span class="c1">// to get the best performance. Inspired by fasthttp at
</span><span class="c1"></span>  <span class="c1">// https://github.com/valyala/fasthttp/blob/master/workerpool.go#L139
</span><span class="c1"></span>  <span class="nx">workerChanCap</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c1">// Use blocking channel if GOMAXPROCS=1.
</span><span class="c1"></span>    <span class="c1">// This switches context from sender to receiver immediately,
</span><span class="c1"></span>    <span class="c1">// which results in higher performance (under go1.5 at least).
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">0</span>
    <span class="p">}</span>

    <span class="c1">// Use non-blocking workerChan if GOMAXPROCS&gt;1,
</span><span class="c1"></span>    <span class="c1">// since otherwise the sender might be dragged down if the receiver is CPU-bound.
</span><span class="c1"></span>    <span class="k">return</span> <span class="mi">1</span>
  <span class="p">}()</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>为了方便对照，我把注释也放上来了。<code>ants</code>参考了著名的 Web 框架<code>fasthttp</code>的实现。当<code>GOMAXPROCS</code>为 1 时（即操作系统线程数为 1），向通道<code>task</code>发送会挂起发送 goroutine，将执行流程转向接收 goroutine，这能提升接收处理性能。如果<code>GOMAXPROCS</code>大于 1，<code>ants</code>使用带缓冲的通道，为了防止接收 goroutine 是 CPU 密集的，导致发送 goroutine 被阻塞。下面是<code>fasthttp</code>中的相关代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="c1">// src/github.com/valyala/fasthttp/workerpool.go
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">workerChanCap</span> <span class="p">=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
  <span class="c1">// Use blocking workerChan if GOMAXPROCS=1.
</span><span class="c1"></span>  <span class="c1">// This immediately switches Serve to WorkerFunc, which results
</span><span class="c1"></span>  <span class="c1">// in higher performance (under go1.5 at least).
</span><span class="c1"></span>  <span class="k">if</span> <span class="nx">runtime</span><span class="p">.</span><span class="nf">GOMAXPROCS</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="p">}</span>

  <span class="c1">// Use non-blocking workerChan if GOMAXPROCS&gt;1,
</span><span class="c1"></span>  <span class="c1">// since otherwise the Serve caller (Acceptor) may lag accepting
</span><span class="c1"></span>  <span class="c1">// new connections if WorkerFunc is CPU-bound.
</span><span class="c1"></span>  <span class="k">return</span> <span class="mi">1</span>
<span class="p">}()</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="自旋锁">自旋锁</h3>
<p><code>ants</code>利用<code>atomic.CompareAndSwapUint32()</code>这个原子操作实现了一个自旋锁。与其他类型的锁不同，自旋锁在加锁失败之后不会立刻进入等待，而是会继续尝试。这对于很快就能获得锁的应用来说能极大提升性能，因为能避免加锁和解锁导致的线程切换：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-golang" data-lang="golang"><span class="kd">type</span> <span class="nx">spinLock</span> <span class="kt">uint32</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sl</span> <span class="o">*</span><span class="nx">spinLock</span><span class="p">)</span> <span class="nf">Lock</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">backoff</span> <span class="o">:=</span> <span class="mi">1</span>
  <span class="k">for</span> <span class="p">!</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">CompareAndSwapUint32</span><span class="p">((</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">sl</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">backoff</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="nx">runtime</span><span class="p">.</span><span class="nf">Gosched</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nx">backoff</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">sl</span> <span class="o">*</span><span class="nx">spinLock</span><span class="p">)</span> <span class="nf">Unlock</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreUint32</span><span class="p">((</span><span class="o">*</span><span class="kt">uint32</span><span class="p">)(</span><span class="nx">sl</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// NewSpinLock instantiates a spin-lock.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">NewSpinLock</span><span class="p">()</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Locker</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">spinLock</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>另外这里使用了<strong>指数退避</strong>，先等 1 个循环周期，通过<code>runtime.Gosched()</code>告诉运行时切换其他 goroutine 运行。如果还是获取不到锁，就再等 2 个周期。如果还是不行，再等 4，8，16&hellip;以此类推。这可以防止短时间内获取不到锁，导致 CPU 时间的浪费。</p>
<h2 id="总结">总结</h2>
<p><code>ants</code>源码短小精悍，没有引用其他任何第三方库。各种细节处理，各种性能优化的点都是值得我们细细品味的。强烈建议大家读一读源码。阅读优秀的源码，能极大地提高自身的编码素养。</p>
<p>大家如果发现好玩、好用的 Go 语言库，欢迎到 Go 每日一库 GitHub 上提交 issue😄</p>
<h2 id="参考">参考</h2>
<ol>
<li>ants GitHub：<a href="https://github.com/panjf2000/ants">github.com/panjf2000/ants</a></li>
<li>Go 每日一库 GitHub：<a href="https://github.com/darjun/go-daily-lib">https://github.com/darjun/go-daily-lib</a></li>
</ol>
<h2 id="我">我</h2>
<p>我的博客：<a href="https://darjun.github.io">https://darjun.github.io</a></p>
<p>欢迎关注我的微信公众号【GoUpUp】，共同学习，一起进步~</p>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">darjun</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2021-06-04
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/2021/06/09/youdontknowgo/pprof/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">你不知道的 Go 之 pprof</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/2021/06/03/godailylib/ants/">
            <span class="next-text nav-default">Go 每日一库之 ants</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "darjun/blog-comments"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:leedarjun@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://github.com/darjun" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://darjun.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2018 -
    2022
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        大俊
        
      </span></span>

  
  
    <span id="busuanzi_container">
      访客数/访问量：<span id="busuanzi_value_site_uv"></span>/<span id="busuanzi_value_site_pv"></span>
    </span>
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  




  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>












</body>
</html>
